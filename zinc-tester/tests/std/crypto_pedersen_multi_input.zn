//# { "cases": [ {
//#     "case": "default",
//#     "input": {
//#         "preimage1": "42",
//#         "preimage2": "127"
//#     },
//#     "expect": true
//# } ] }

use std::convert::to_bits;
use std::crypto::pedersen;
use std::crypto::pedersen_multi_input;

const PEDERSEN_HASH_SIZE: u64 = 254;
const INT32_BITS:u8 = 32; 

fn main(preimage1: u32, preimage2:u32) -> bool {
    
    let preimage_bits_1: [bool; INT32_BITS] = to_bits(preimage1);
    let preimage_bits_2: [bool; INT32_BITS] = to_bits(preimage2);
    
    //multi input digest
    let digest_multi_input = pedersen_multi_input(preimage_bits_1, preimage_bits_2);

    //Bytes
    let digest_bits_multi_input = std::convert::to_bits(digest_multi_input.0); 

    //Concatenated digest
    let mut preimage_bits_concatenated : [bool; 2 * INT32_BITS] = [false; 2 * INT32_BITS];
    preimage_bits_concatenated[0..INT32_BITS] = preimage_bits_1;
    preimage_bits_concatenated[INT32_BITS..(2* INT32_BITS)] = preimage_bits_2; 

    let digest_concatenated = pedersen(preimage_bits_concatenated);

    //Bytes
    let digest_bits_concatenated = std::convert::to_bits(digest_concatenated.0); 

    //Comparison
    let mut isEqual = true; 
    for i in 0..PEDERSEN_HASH_SIZE {
        if(digest_bits_multi_input[i] != digest_bits_concatenated[i]){
            isEqual = false; 
        }
    }

    isEqual
}
