<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Merkle tree - Zinc v0.2.1</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The official Zinc book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../01-design-background.html"><strong aria-hidden="true">1.</strong> Design background</a></li><li class="chapter-item expanded "><a href="../02-getting-started/00-overview.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02-getting-started/01-require-function.html"><strong aria-hidden="true">2.1.</strong> Require</a></li><li class="chapter-item expanded "><a href="../02-getting-started/02-standard-libraries.html"><strong aria-hidden="true">2.2.</strong> Standard libraries</a></li><li class="chapter-item expanded "><a href="../02-getting-started/03-debugging.html"><strong aria-hidden="true">2.3.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="../02-getting-started/04-testing.html"><strong aria-hidden="true">2.4.</strong> Testing</a></li></ol></li><li class="chapter-item expanded "><a href="../03-variables-and-types/00-overview.html"><strong aria-hidden="true">3.</strong> Variables and types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-variables-and-types/01-variables.html"><strong aria-hidden="true">3.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../03-variables-and-types/02-types/00-overview.html"><strong aria-hidden="true">3.2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-variables-and-types/02-types/01-scalar.html"><strong aria-hidden="true">3.2.1.</strong> Scalar</a></li><li class="chapter-item expanded "><a href="../03-variables-and-types/02-types/02-arrays.html"><strong aria-hidden="true">3.2.2.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../03-variables-and-types/02-types/03-tuples.html"><strong aria-hidden="true">3.2.3.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="../03-variables-and-types/02-types/04-structures.html"><strong aria-hidden="true">3.2.4.</strong> Structures</a></li><li class="chapter-item expanded "><a href="../03-variables-and-types/02-types/05-enumerations.html"><strong aria-hidden="true">3.2.5.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../03-variables-and-types/02-types/06-strings.html"><strong aria-hidden="true">3.2.6.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../03-variables-and-types/02-types/07-casting-and-conversions.html"><strong aria-hidden="true">3.2.7.</strong> Casting and conversions</a></li><li class="chapter-item expanded "><a href="../03-variables-and-types/02-types/08-maps.html"><strong aria-hidden="true">3.2.8.</strong> Maps</a></li></ol></li><li class="chapter-item expanded "><a href="../03-variables-and-types/03-functions.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li></ol></li><li class="chapter-item expanded "><a href="../04-operators/00-overview.html"><strong aria-hidden="true">4.</strong> Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-operators/01-arithmetic.html"><strong aria-hidden="true">4.1.</strong> Arithmetic</a></li><li class="chapter-item expanded "><a href="../04-operators/02-bitwise.html"><strong aria-hidden="true">4.2.</strong> Bitwise</a></li><li class="chapter-item expanded "><a href="../04-operators/03-comparison.html"><strong aria-hidden="true">4.3.</strong> Comparison</a></li><li class="chapter-item expanded "><a href="../04-operators/04-logical.html"><strong aria-hidden="true">4.4.</strong> Logical</a></li><li class="chapter-item expanded "><a href="../04-operators/05-casting.html"><strong aria-hidden="true">4.5.</strong> Casting</a></li><li class="chapter-item expanded "><a href="../04-operators/06-access.html"><strong aria-hidden="true">4.6.</strong> Access</a></li><li class="chapter-item expanded "><a href="../04-operators/07-range.html"><strong aria-hidden="true">4.7.</strong> Range</a></li><li class="chapter-item expanded "><a href="../04-operators/08-assignment.html"><strong aria-hidden="true">4.8.</strong> Assignment</a></li></ol></li><li class="chapter-item expanded "><a href="../05-expressions/00-overview.html"><strong aria-hidden="true">5.</strong> Expressions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05-expressions/01-literals.html"><strong aria-hidden="true">5.1.</strong> Literals</a></li><li class="chapter-item expanded "><a href="../05-expressions/02-blocks.html"><strong aria-hidden="true">5.2.</strong> Blocks</a></li><li class="chapter-item expanded "><a href="../05-expressions/03-conditionals.html"><strong aria-hidden="true">5.3.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="../05-expressions/04-constant.html"><strong aria-hidden="true">5.4.</strong> Constant</a></li></ol></li><li class="chapter-item expanded "><a href="../06-statements/00-overview.html"><strong aria-hidden="true">6.</strong> Statements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../06-statements/01-declaration.html"><strong aria-hidden="true">6.1.</strong> Declaration</a></li><li class="chapter-item expanded "><a href="../06-statements/02-expression.html"><strong aria-hidden="true">6.2.</strong> Expression</a></li><li class="chapter-item expanded "><a href="../06-statements/03-control.html"><strong aria-hidden="true">6.3.</strong> Control</a></li></ol></li><li class="chapter-item expanded "><a href="../07-smart-contracts/00-overview.html"><strong aria-hidden="true">7.</strong> Smart contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../07-smart-contracts/01-storage-and-methods.html"><strong aria-hidden="true">7.1.</strong> Storage and methods</a></li><li class="chapter-item expanded "><a href="../07-smart-contracts/02-minimal-example.html"><strong aria-hidden="true">7.2.</strong> Minimal example</a></li><li class="chapter-item expanded "><a href="../07-smart-contracts/03-curve-implementation.html"><strong aria-hidden="true">7.3.</strong> The Curve</a></li><li class="chapter-item expanded "><a href="../07-smart-contracts/04-troubleshooting.html"><strong aria-hidden="true">7.4.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="../08-circuits/00-overview.html"><strong aria-hidden="true">8.</strong> Zero-knowledge circuits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../08-circuits/01-input-output.html"><strong aria-hidden="true">8.1.</strong> Input and output</a></li><li class="chapter-item expanded "><a href="../08-circuits/02-minimal-example.html"><strong aria-hidden="true">8.2.</strong> Minimal example</a></li><li class="chapter-item expanded "><a href="../08-circuits/03-merkle-tree.html" class="active"><strong aria-hidden="true">8.3.</strong> The Merkle tree</a></li></ol></li><li class="chapter-item expanded "><a href="../09-virtual-machine/00-overview.html"><strong aria-hidden="true">9.</strong> Virtual machine</a></li><li class="chapter-item expanded "><a href="../10-zargo/00-overview.html"><strong aria-hidden="true">10.</strong> Zargo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../10-zargo/01-contract-workflow.html"><strong aria-hidden="true">10.1.</strong> Contract workflow</a></li><li class="chapter-item expanded "><a href="../10-zargo/02-circuit-workflow.html"><strong aria-hidden="true">10.2.</strong> Circuit workflow</a></li></ol></li><li class="chapter-item expanded "><a href="../appendix/_overview.html"><strong aria-hidden="true">11.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../appendix/A-grammar-lexical.html"><strong aria-hidden="true">11.1.</strong> A - Lexical grammar</a></li><li class="chapter-item expanded "><a href="../appendix/B-grammar-syntax.html"><strong aria-hidden="true">11.2.</strong> B - Syntax grammar</a></li><li class="chapter-item expanded "><a href="../appendix/C-keywords.html"><strong aria-hidden="true">11.3.</strong> C - Keywords</a></li><li class="chapter-item expanded "><a href="../appendix/D-intrinsic-functions.html"><strong aria-hidden="true">11.4.</strong> D - Intrinsic functions</a></li><li class="chapter-item expanded "><a href="../appendix/E-standard-library.html"><strong aria-hidden="true">11.5.</strong> E - The standard library</a></li><li class="chapter-item expanded "><a href="../appendix/F-zksync-library.html"><strong aria-hidden="true">11.6.</strong> F - The zkSync library</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Zinc v0.2.1</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-merkle-tree" id="the-merkle-tree">The Merkle tree</a></h1>
<p>In this chapter, we will implement a circuit able to validate the Merkle tree
root hash.</p>
<p>At this stage of reading the book, you may be unfamiliar with some language
concepts. So, if you struggle to understand some examples, you are welcome to
read the rest of the book first, and then come back.</p>
<p>Our circuit will accept the tree node path, address, and the balance available
as the secret witness data. The public data will be the Merkle tree root hash.</p>
<h2><a class="header" href="#creating-a-new-project" id="creating-a-new-project">Creating a new project</a></h2>
<p>Let's create a new circuit called <code>merkle-proof</code>:</p>
<pre><code class="language-bash no_run noplaypen">zargo new --type circuit merkle-proof
cd merkle-proof
</code></pre>
<p>Now, you can open the project in your favorite IDE and go to <code>src/main.zn</code>,
where we are going to start writing the circuit code.</p>
<h2><a class="header" href="#defining-types" id="defining-types">Defining types</a></h2>
<p>Let's start by defining the secret witness data arguments and the public data
return type.</p>
<pre><code class="language-rust no_run noplaypen">struct PublicInput {
    root_hash: [bool; 256],
}

fn main(
    address: [bool; 10], // the node address in the merkle tree
    balance: field, // the balance stored in the node
    merkle_path: [[bool; 256]; 10] // the hash path to the node
) -&gt; PublicInput {
    // ...
}
</code></pre>
<p>As you can see, some complex types are used in several places of our code, so
it is very convenient to create an alias for such type.</p>
<pre><code class="language-rust no_run noplaypen">type Sha256Digest = [bool; 256];
</code></pre>
<h2><a class="header" href="#creating-functions" id="creating-functions">Creating functions</a></h2>
<p>Now, we will write a function to calculate the <code>sha256</code> hash of
our balance. We need it to verify the balance stored within the leaf node at our
Merkle tree path.</p>
<pre><code class="language-rust no_run noplaypen">fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance); // [bool; 254]
    let bits_padded = std::array::pad(bits, 256, false); // [bool; 256]
    std::crypto::sha256(bits_padded) // [bool; 256] a.k.a. Sha256Digest
}
</code></pre>
<p>The function accepts <code>balance</code> we passed as secret witness data, converts it
into a bit array of length 254 (elliptic curve field length), and pads the
array with 2 extra zero bits, since we are going to pass a 256-bit array to the
<code>sha256</code> function.</p>
<p>We have also used here three functions from the <a href="../appendix/E-standard-library.html">standard library</a>
from three different modules. Paths like <code>std::crypto::sha256</code> might seem a
bit verbose, but we will solve this problem later.</p>
<p>At this stage, this is how our code looks like:</p>
<pre><code class="language-rust no_run noplaypen">type Sha256Digest = [bool; 256];

struct PublicInput {
    root_hash: Sha256Digest,
}

fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance); // [bool; 254]
    let bits_padded = std::array::pad(bits, 256, false); // [bool; 256]
    std::crypto::sha256(bits_padded) // [bool; 256] a.k.a. Sha256Digest
}

fn main(
    address: [bool; 10], // the node address in the merkle tree
    balance: field, // the balance stored in the node
    merkle_path: [Sha256Digest; 10] // the hash path to the node
) -&gt; PublicInput {
    let leaf_hash = balance_hash(balance);

    // ...
}
</code></pre>
<p>Now, we need a function to calculate a tree node hash:</p>
<pre><code class="language-rust no_run noplaypen">fn merkle_node_hash(left: Sha256Digest, right: Sha256Digest) -&gt; Sha256Digest {
    let mut data = [false; 512]; // [bool; 512]

    // Casting to u16 is needed to make the range types equal,
    // since 0 will be inferred as u8, and 256 - as u16.
    for i in 0 as u16..256 {
        data[i] = left[i];
        data[256 + i] = right[i];
    }

    std::crypto::sha256(data) // [bool; 256] a.k.a. Sha256Digest
}
</code></pre>
<p>The Zinc standard library does not support array concatenation yet, so for now,
we will do it by hand, allocating an array to contain two leaves node digests,
then put the digests together and hash them with <code>std::crypto::sha256</code>.</p>
<p>Finally, let's define a function to calculate the hash of the whole tree:</p>
<pre><code class="language-rust no_run noplaypen">fn restore_root_hash(
    leaf_hash: Sha256Digest,
    address: [bool; 10],
    merkle_path: [Sha256Digest; 10],
) -&gt; Sha256Digest
{
    let mut current = leaf_hash; // Sha256Digest

    // Traverse the tree from the left node to the root node
    for i in 0..10 {
        // Multiple variables binding is not supported yet,
        // so we going to store leaves as an array of two digests.
        // If address[i] is 0, we are in the left node, otherwise,
        // we are in the right node.
        let left_and_right = if address[i] {
            [current, merkle_path[i]] // [Sha256Digest; 2]
        } else {
            [merkle_path[i], current] // [Sha256Digest; 2]
        };

        // remember the current node hash
        current = merkle_node_hash(left_and_right[0], left_and_right[1]);
    }

    // return the root node hash
    current
}
</code></pre>
<p>Congratulations! Now we have a working circuit able to verify the Merkle proof!</p>
<pre><code class="language-rust no_run noplaypen">// main.zn

type Sha256Digest = [bool; 256];

fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance); // [bool; 254]
    let bits_padded = std::array::pad(bits, 256, false); // [bool; 256]
    std::crypto::sha256(bits_padded) // [bool; 256] a.k.a. Sha256Digest
}

fn merkle_node_hash(left: Sha256Digest, right: Sha256Digest) -&gt; Sha256Digest {
    let mut data = [false; 512]; // [bool; 512]

    for i in 0..256 {
        data[i] = left[i];
        data[256 + i] = right[i];
    }

    std::crypto::sha256(data) // [bool; 256] a.k.a. Sha256Digest
}

fn restore_root_hash(
    leaf_hash: Sha256Digest,
    address: [bool; 10],
    merkle_path: [Sha256Digest; 10],
) -&gt; Sha256Digest
{
    let mut current = leaf_hash; // Sha256Digest

    // Traverse the tree from the left node to the root node
    for i in 0..10 {
        // Multiple variables binding is not supported yet,
        // so we going to store leaves as a tuple of two digests.
        // If address[i] is 0, we are in the left node, otherwise,
        // we are in the right node.
        let left_and_right = if address[i] {
            (current, merkle_path[i]) // (Sha256Digest, Sha256Digest)
        } else {
            (merkle_path[i], current) // (Sha256Digest, Sha256Digest)
        };

        // remember the current node hash
        current = merkle_node_hash(left_and_right.0, left_and_right.1);
    }

    // return the root node hash
    current
}

struct PublicInput {
    root_hash: Sha256Digest,
}

fn main(
    address: [bool; 10],
    balance: field,
    merkle_path: [Sha256Digest; 10]
) -&gt; PublicInput {
    let leaf_hash = balance_hash(balance);

    let root_hash = restore_root_hash(
        leaf_hash,
        address,
        merkle_path,
    );

    PublicInput {
        root_hash: root_hash,
    }
}
</code></pre>
<h2><a class="header" href="#defining-a-module" id="defining-a-module">Defining a module</a></h2>
<p>Our <code>main.zn</code> module has got a little overpopulated by now, so let's move our
functions to another one called <code>merkle</code>. At first, create a file called <code>merkle.zn</code>
in the <code>src</code> directory besides <code>main.zn</code>. Then, move everything above the
<code>PublicInput</code> definition to that file. Our <code>main.zn</code> will now look like this:</p>
<pre><code class="language-rust no_run noplaypen">struct PublicInput {
    root_hash: Sha256Digest, // undeclared `Sha256Digest`
}

fn main(
    address: [bool; 10],
    balance: field,
    merkle_path: [Sha256Digest; 10] // undeclared `Sha256Digest`
) -&gt; PublicInput {
    let leaf_hash = balance_hash(balance); // undeclared `balance_hash`

    let root_hash = restore_root_hash( // undeclared `restore_root_hash`
        leaf_hash,
        address,
        merkle_path,
    );

    PublicInput {
        root_hash: root_hash,
    }
}
</code></pre>
<p>This code will not compile, as we have several items undeclared now! Let's
define our <code>merkle</code> module and resolve the function paths:</p>
<pre><code class="language-rust no_run noplaypen">mod merkle; // defined a module

struct PublicInput {
    root_hash: merkle::Sha256Digest, // use a type declaration from `merkle`
}

fn main(
    address: [bool; 10],
    balance: field,
    merkle_path: [merkle::Sha256Digest; 10] // use a type declaration from `merkle`
) -&gt; PublicInput {
    let leaf_hash = merkle::balance_hash(balance); // call a function from `merkle`

    // call a function from `merkle`
    let root_hash = merkle::restore_root_hash(
        leaf_hash,
        address,
        merkle_path,
    );

    PublicInput {
        root_hash: root_hash,
    }
}
</code></pre>
<p>Perfect! Now all our functions and types are defined. By the way, let's have a
glance at our <code>merkle</code> module, where you can find another improvement!</p>
<pre><code class="language-rust no_run noplaypen">use std::crypto::sha256; // an import

type Sha256Digest = [bool; 256];

fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance);
    let bits_padded = std::array::pad(bits, 256, false);
    sha256(bits_padded)
}

fn merkle_node_hash(left: Sha256Digest, right: Sha256Digest) -&gt; Sha256Digest {
    let mut data = [false; 512];

    for i in 0..256 {
        data[i] = left[i];
        data[256 + i] = right[i];
    }

    sha256(data)
}

fn restore_root_hash(
    leaf_hash: Sha256Digest,
    address: [bool; 10],
    merkle_path: [Sha256Digest; 10],
) -&gt; Sha256Digest
{
    let mut current = leaf_hash;

    for i in 0..10 {
        let left_and_right = if address[i] {
            (current, merkle_path[i])
        } else {
            (merkle_path[i], current)
        };

        current = merkle_node_hash(left_and_right.0, left_and_right.1);
    }

    current
}
</code></pre>
<p>You may notice a <code>use</code> statement at the first line of code. It is an import statement
which is designed to prevent using long repeated paths in our code. As you see,
now we are able to call the standard library function more conveniently:
<code>sha256(data)</code> instead of <code>std::crypto::sha256(data)</code>.</p>
<h2><a class="header" href="#finalizing" id="finalizing">Finalizing</a></h2>
<p>Congratulations, you are an experienced Zinc developer!
Now, you may build the circuit, generate and verify a proof, like it was
explained in the <a href="./02-minimal-example.html">previous chapter</a>,
and move on to reading the rest of the book!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../08-circuits/02-minimal-example.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../09-virtual-machine/00-overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../08-circuits/02-minimal-example.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../09-virtual-machine/00-overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
